##############
# Versioning #
##############

HCP_VER_MAJOR := 1
HCP_VER_MINOR := 1
HCP_VER := $(HCP_VER_MAJOR):$(HCP_VER_MINOR)

#######################################
# Top-level control, defaults, config #
#######################################

TOP := $(shell pwd)
Q := $(if $(strip $V),,@)

include settings.mk

HCP_OUT ?= $(TOP)/build
MDIRS += $(HCP_OUT)

# Used in dependency chains, as a change in these files can have effects that
# require rebuilding other things.
ifndef SAFEBOOT_HCP_RELAX
HCP_DEPS_COMMON := $(TOP)/Makefile $(HCP_SRC)/settings.mk $(HCP_SRC)/Makefile
endif

########################
# Detect current state #
########################

# To generate rules in smarter ways, first capture lists of images and networks
# that already exist. TODO: have these two lists be files that are dependent on
# a touchfile that gets touched any time the list might be out of date (when an
# image is built, for example). Then we can avoid $(shell)ing to "docker image
# ls" and "docker network ls" every time 'make' is run, and instead we can
# unilaterally call a sub-make that only runs it if the dependency is out of
# date. Note, this is wiser than updating the lists directly and avoiding
# running 'docker', because we run docker precisely to "recover" from cases
# where the user/admin has explicitly created or removed things and our lists
# are no longer accurate. In this case, we only need a rule to touch the
# touchfiles and then the lists get updated and we can move forward. (Of
# course, for the regular case, the rule that touches a touchfile can also
# invoke the sub-make to update the list at the same time. This would be better
# UX, because it won't slow the tab-completion of the next command-line use of
# 'make'.)
HCP_EXISTING_IMAGES := $(shell docker image ls \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Repository}}:{{.Tag}}" 2> /dev/null)
HCP_EXISTING_NETWORKS := $(shell docker network ls \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Name}}" 2> /dev/null)

# General-purpose, lazy-initialization directory creation. Adding any path to
# MDIRS ensures it gets this rule. That's why it's the the last declaration.
# Note, we deliberately avoid "mkdir -p". It's a discipline measure, to ensure
# things don't get sloppy over time. If make tries to create a child directory
# before creating its parent, that's either because the child is in MDIRS but
# the parent isn't, or we're missing a "|" dependency (of the child upon the
# parent) to control the ordering.

#############
# Templates #
#############

# TODO: tidy this up and factor it out into an include.
# There are various components that get produced as tarballs after being staged in
# host directories (under build/), and these are later consumed by Dockerfiles that
# have autogenerated commands appended to them by the build system. To avoid
# host oddities influencing the images (e.g. via umasks, setuid/setgid bits,
# ...), we use the following constructs for all tarball extractions;

# tarball_extract adds Dockerfile commands to copy foobar.tar.gz to the
# container image, extract it into a well-known temporary location, and then
# remove the tarball;
#     echo "$(call tarball_extract,foobar)" >> some/random/Dockerfile
tarball_extract = \# From tarball_extract($1)
tarball_extract += \nCOPY $1.tar.gz /
tarball_extract += \nRUN mkdir -p /tmp-hcp-tarball
tarball_extract += \nRUN cd /tmp-hcp-tarball && tar zxf /$1.tar.gz && rm /$1.tar.gz

# tarball_finalize adds Dockerfile commands to chown and chmod the directories
# and files from the well-known temporary directory, then move them all to the
# root directory and remove the temporary directory. Multiple tarball_extract
# sections can preceed the single (parameter-less) tarball_finalize section;
#     echo "$(call tarball_finalize)" >> some/random/Dockerfile
tarball_finalize = \# From tarball_finalize()
tarball_finalize += \nRUN cd /tmp-hcp-tarball && chown -R root:root *
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . -type d -exec chmod 755 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . ! -type d -executable -exec chmod 755 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . ! -type d ! -executable -exec chmod 644 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && mv * / && cd / && rmdir /tmp-hcp-tarball

#############
# Workflows #
#############

# A "base platform" Docker image is created, and used as a basis for deriving
# two kinds of images;
# - a "builder" container image, containing tool-chains and other extras to
#   facilitate the building of safeboot submodules.
# - application container images, providing the different services, side-cars,
#   and utilities that constitue HCP.
include workflow/base/Makefile

# A "builder" docker image is created that can host safeboot's building of
# submodule code (rather than building directly in the host environment, which
# can be undesirable, unreliable, or impossible for many reasons).
include workflow/builder/Makefile

# TODO: rename submodules to 'upstream-tools'
# Compile submodules (using "builder"), resulting in install.tar.gz, literally
# a tarball of a root-level installation ("/install") of the submodules.
include workflow/submodules/Makefile

# TODO: split or clarify, so 'safeboot' isn't blurred with 'apps'
# Produce tarballs of scripts, for installation into containers. This includes
# safeboot.tar.gz (literally a tarball of safeboot scripts in an installed
# path) and hcp-<x>.tar.gz for <x> in {enrollsvc,attestsvc,swtpmsvc,client}.
include workflow/scripts/Makefile

# TODO: the creating, destroy, starting, and stopping of instances (both
# Enrollment and Attestation) is currently mingled into the Makefiles that
# build the service containers. This will change. But for now, we want those
# instances to connect to each other on a docker network, so provide the
# definitions and support before including the Enrollment/Attestation Service
# Makefiles.
include workflow/testnetwork.Makefile

# Enrollment Service
include workflow/enrollsvc/Makefile

# Attestation Service
include workflow/attestsvc/Makefile

# Software TPM
include workflow/swtpmsvc/Makefile

# Example client/host (containerized)
include workflow/client/Makefile

# A devel/debug image that has the whole kit and caboodle
include workflow/caboodle/Makefile

########################
# Hierarchical cleanup #
########################

# This can be used as an order-only dependency (after a "|") for all "clean_*"
# rules that try to remove a container image. Why? Because even if we always
# pass "--rm" to docker-run, we can't entirely rid ourselves of
# exited-but-not-removed containers: if docker-build launches a container to
# run a Dockerfile command and it fails, _that_ container will linger, and in
# doing so it will prevent the removal of container images that are ancestors
# of it! Thus - this rule provides a way to detect that particular class of
# exited containers and remove them. Making sure it runs before your cleanup
# routine helps ensure your "docker imgae rm" statements don't fail.
preclean:
	$Qdocker container ls -a -q --filter=label=$(SAFEBOOT_HCP_DSPACE)all | \
		xargs -r docker container rm

# As a discipline measure, we use 'rmdir' rather than 'rm -rf'. The concept is
# that the hierarchy of stuff that gets created inside $(HCP_OUT) should have
# corresponding clean targets and dependencies. Any child target should declare
# the parent to be dependent on it, to ensure that child rules run before
# parent rules.  This means that 'clean' should be dependent on the entire tree
# of cleanup targets for everything created underneath it, and so the rule for
# 'clean' should run after everything else. If everything is covered, nothing
# will be left and 'rmdir' will suffice. If we have to use 'rm -rf', it's
# because there are elements getting created that don't have a corresponding
# cleanup rule, or it's incomplete, or it hasn't created dependency hooks
# appropriately.
clean:
	$Qrmdir $(HCP_OUT)

#######################
# Lazy-initialization #
#######################

$(MDIRS):
	$Qmkdir $@
