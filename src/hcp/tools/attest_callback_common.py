#!/usr/bin/python3

import glob
import subprocess
import shutil
import os
import sys
import re
import filecmp
import json
import pwd

sys.path.insert(1, '/hcp/common')
from hcp_common import log, bail, hcp_config_extract

if 'VERBOSE' in os.environ:
	def verbose(s):
		print(s)
else:
	def verbose(s):
		pass

# This callback, if registered in HCP_ATTESTCLIENT_CALLBACKS, serves to hoover
# up various assets generated by enrollsvc "genprogs" and perform some kind of
# standard/common treatment.
#
# For any assets that should get more specific handling than what is done here,
# callbacks should be defined to do that work and they should be listed in
# HCP_ATTESTCLIENT_CALLBACKS earlier than this one (to ensure it runs before
# hand). If those callbacks leave those assets in the source (current)
# directory when exiting, then this callback will still pick up on them and
# perform the standard treatment. To avoid this, those callbacks should remove
# the source assets before exiting.

log("Starting attest_callback_common")

myid = hcp_config_extract('id', or_default = True, default = 'unknown_id')
myglobal = hcp_config_extract('client.global', or_default = True, default = False)
if not isinstance(myglobal, bool):
	bail(f"'client.global' must be bool (not {type(myglobal)})")
if myglobal:
	etc = '/etc'
else:
	etc = f"/etc/hcp/{myid}"

# IMPORTANT NOTE ABOUT USERS: one goal of this way of working is to demonstrate
# an SSO solution among a network of "hosts". Ie. HCP can provide TPM-protected
# creds to a host (via attestation) that allow some "user" (an identity,
# typically 1:1 with the Kerberos concept of a principal) to access other
# hosts. That identity might have separate accounts on the different hosts, and
# they may have different usernames too. (In the "monolith" case, these "hosts"
# are actually just co-tenant workloads in a single container, so we actually
# _have_ to use differently named accounts in order to maintain the illusion of
# multiple hosts.)
#
# In this callback, we're interested in where to put incoming user credentials,
# given that they are for an "identity" that won't necessarily be a literal
# match for the local account/username corresponding to that identity.
#
# So ... the "client" section of the JSON config can optionally define a
# "usermap" sub-section, that can convert the usernames of incoming creds to
# local account names, if they differ. Eg.
#    { "foo": "joe467", "bar": "whatever" }
# This maps two identities coming from HCP (per the enrollment, file-naming of
# assets, etc) to different user IDs on the local host. Only identities
# mentioned in that map file get translated, so any identity other than "foo"
# or "bar" will be used (without transformation) as local usernames,
# successfully or otherwise. In this example, if and when HCP provides us with
# a user-scoped cred for the user 'foo', this attestation callback will
# immediately map that to the user 'joe467' and forget about 'foo'. So the
# rules about ownership of the cred and where (or if) it gets installed will be
# entirely based on 'joe467' in that case.
_usermap = hcp_config_extract("client.usermap", or_default = True, default = {})
if not isinstance(_usermap, dict):
	bail(f"'client.usermap' must be 'dict' (not {type(_usermap)})")
for k in _usermap:
	v = _usermap[k]
	# TODO: perhaps k and v should undergo more stringent checks,
	# ie. that they look like user IDs, not just that they're
	# strings.
	if not isinstance(k, str) or not isinstance(v, str):
		bail(f"{path_usermap} must only container string mappings")
def usermap(name):
	if name in _usermap:
		log(f"usermap: '{name}' -> '{_usermap[name]}'")
		return _usermap[name]
	log(f"usermap: '{name}' unmodified")
	return name

# This comes in handy
def lazy_makedirs(d):
	if not os.path.isdir(d):
		log(f"lazy_makedirs() creating: {d}")
		os.makedirs(d, mode = 0o755)
	return d

# Generic pre/post hook handling. If "{fname}_PRE" or "{fname}_POST"
# are defined (in the environment), their values are interpreted as executable
# paths that shoud be run if any of this asset's files have changed in the
# enrollment received from the last attestation. A JSON presentation of the
# 'assets' array will written to the process's stdin. An example of the format
# is here, and note that at least one of the booleans will be true. (This would
# occur, for example, when automatic reenrollment occurs, meaning that a new
# certificate might be issued for the same/unchanging private key.)
#    [
#        ( "{etc}/https-server/foo.hcphacking.xyz.pem", True),
#        ( "{etc}/https-server/foo.hcphacking.xyz-key.pem", False)
#    ]
def gen_preinstall(fname, assets):
	if fname and f"{fname}_PRE" in os.environ:
		prog = os.environ[f"{fname}_PRE"]
		subprocess.run([prog, fname], text = True,
				input = json.dumps(assets))
def gen_postinstall(fname, assets):
	if fname and f"{fname}" in os.environ:
		prog = os.environ[f"{fname}"]
		prog = prog.split()
		subprocess.run(prog + [ fname ], text = True,
				input = json.dumps(assets))

# Method for assets that need typical {etc}/<foo> handling
def method_etc(filematch):
	return {
		# This method belongs to a 'class' that already has a glob
		# pattern to identify files of interest in the current
		# directory (a temp extraction of the enrollment data). For
		# each filename, it calls this 'fn' handler. The return from
		# the handler is a list/array of zero or more asset records,
		# called an 'asset bundle'. 'fn' may examine the files passed
		# to it to determine their relevance or may not need to. And
		# for any given invocation, 'fn' may return an empty list - eg.
		# when the file is to be ignored, or if it is part of an
		# asset-bundle and you only want to return that list when 'fn'
		# is invoked for a particular 'leader' file in the bundle. (Eg.
		# perhaps the glob matches on multiple files for the same
		# bundle, and you want to ensure 'fn' only returns non-empty
		# for one of them.) Also, the subsequent preinstall/postinstall
		# hooks get called once per asset bundle, so you want 'fn' to
		# triage the filenames it gets called for (based on that glob)
		# and (only) return a list of filenames (only) when
		# appropriate.
		# - inputs: filename, the handler using this method
		# - outputs: arbitrary-length (and possibly-empty) array of
		#            dicts: (fname, dest_path, chmod_mode)
		'fn': lambda fname, _class: [ {
			'name': fname,
			'dest': f"{etc}/{fname}",
			'mode': 0o644 } ],
		# (Optional) hook to run before installing. This runs once for
		# each asset-bundle that 'fn' returns.
		# - input: list/array of asset records (same dicts as those
		#   returned from 'fn', but with a boolean-valued 'is_changed'
		#   added to it)
		'preinstall': lambda assets: gen_preinstall(filematch, assets),
		# (Optional) like preinstall, but run after installing.
		'postinstall': lambda assets: gen_postinstall(filematch, assets)
	}

# Similar to method_etc(), but handles krb5.keytab updates via ktutil
def method_keytab(filematch):
	def fn(fname, _class):
		log(f"keytabs::fn({fname}) starting")
		d = lazy_makedirs(f"{etc}")
		dest = f"{d}/{fname}.updated"
		return [ {
			'name': fname,
			'dest': dest,
			'mode': 0o644 } ]
	def krb5update(assets):
		if len(assets) != 1:
			bail("method_keytab::fn expects single assets only")
		a = assets[0]
		log(f"krb5update({a})")
		if not a['dest'].endswith('.updated'):
			bail("method_keytab::fn expects '{foo}'.updated assets")
		# k = destination keytab
		k = a['dest'].replace('.updated', '')
		log(f"- dest: {k}")
		# Copy keys into destination
		args = [ 'ktutil', 'copy', a['dest'], k ]
		log(f"running subprocess: {args}")
		c = subprocess.run(args)
		# purge keys older than 1 day (TODO: configurable!)
		args = [ 'ktutil', f"--keytab={k}", 'purge', '--age=3d' ]
		log(f"running subprocess: {args}")
		c = subprocess.run(args)
		# Before callbacks run, fix the asset paths to the real destination
		a['dest'] = k
		# invoke any callbacks
		gen_postinstall(filematch, assets)
	return {
		'fn': fn,
		'preinstall': lambda assets: gen_preinstall(filematch, assets),
		'postinstall': krb5update
	}

# Subroutine of method_hostcerts, which processes the common prefix of both
# files (the cert "*.pem" and the key "*-key.pem"). This returns 3-tuple
# (owner, destpath, destprefix), where owner is a userid (int) or None
# (for root), and destpath/destprefix determines the output paths;
#    cert -> f"{destpath}/{destprefix}.pem"
#     key -> f"{destpath}/{destprefix}-key.pem"
# The mapping implemented here needs to be kept in sync with other,
# interdependent configuration like emgmt.json, emgmt_pol.policy.json,
# fleet.json, etc.
#
# Root/host-scoped creds have a "default-" prefix that take the form;
# "default-<cat>-<subcat>". As a general rule, they are mapped to an
# the installation prefix; {etc}/<cat>/<subcat>".

# Exception: if the category is 'https' and the subcategory begins with
# 'server' or 'hostclient', the dNSName field of the certificate is extracted
# and used in the mapping;
#     default-https-server*   -->  {etc}/https-server/<dNSName>
#   default-https-hostclient* -->  {etc}/https-hostclient/<dNSName>
#
# User-scoped creds take the form; "user-<cat>-<subcat>-<user>". The order may
# seem strange, but this is because unix IDs can legally contain '-' characters
# so we want it to be the last component in the split(). This means <cat> and
# <subcat> can't use '-' characters, so underscores are a good alternative.
# The <user> value will pass through the usermap() function, which may modify
# it. The result is <localuser> in the following discussion, and we replace
# <user> with <origuser> for clarity.
# If <localuser> exists on the system, the installed creds will be owned by
# that user. The installation mapping also depends on whether <localuser> has a
# home directory;
# If <localuser> exists and has a $HOME directory;
#     $HOME/.hcp/<cat>/<subcat>-<origuser>
# If <localuser> exists and has no $HOME directory;
#     {etc}/creds/role/<localuser>/<cat>/<subcat>-<origuser>
# If <localuser> doesn't exist;
#     {etc}/creds/unknown/<localuser>/<cat>/<subcat>-<origuser>
#
# Creds that don't match the above formats are ignored.
#
# Eg.
#   default-pkinit-kdc.pem       ->   {etc}/pkinit/kdc.pem
#   default-pkinit-iprop.pem     ->   {etc}/pkinit/iprop.pem
# (and now skipping the '.pem' for brevity)
#   default-https-server3        ->   {etc}/https-server/<HOSTNAME>
#   default-https-hostclient-bob ->   {etc}/https-hostclient/<HOSTNAME>
#   default-https-foo            ->   {etc}/https/foo
#   user-pkinit-id-bob           ->   ~bob/.hcp/pkinit/id-bob
#   user-pkinit-admin-bob        ->   ~bob/.hcp/pkinit/admin-bob
#   user-email-authn-bob         ->   ~bob/.hcp/email/auth-bob
#   user-pkinit-id-role7         ->   {etc}/creds/role/role7/pkinit/id-role7
#   user-pkinit-authz-www-data   ->   {etc}/creds/role/www-data/pkinit/authz-www-data
#   user-email-authn-foo         ->   {etc}/creds/unknown/foo/email/authn-foo
#
# IMPORTANT NOTE ABOUT USERS: see the earlier note about HCP_USERMAP, that
# applies here.

re_pem_prog = re.compile('\\.pem$')
re_key_prog = re.compile('-key\\.pem$')

def map_hostcert(prefix):
	log(f"map_hostcert({prefix})")
	if not prefix.startswith('hostcert-'):
		log(f"skipping, we only map 'hostcert-*' prefixes")
		return -1, None, None
	trimmed = prefix.replace('hostcert-', '')
	split3 = trimmed.split('-', maxsplit = 2)
	split4 = trimmed.split('-', maxsplit = 3)
	log(f"split3={split3}")
	log(f"split4={split4}")
	# None == 'root'
	uid = 1
	if split3[0] == 'default':
		if len(split3) != 3:
			log(f"map_hostcert({prefix}), no default mapping")
			return -1, None, None
		log(f"following 'default' handling")
		cat = split3[1]
		subcat = split3[2]
		if cat == 'https' and (subcat.startswith('server') or \
					subcat.startswith('hostclient')):
			log(f"following 'https' handling")
			if subcat.startswith('server'):
				d = lazy_makedirs(f"{etc}/https-server")
			else:
				d = lazy_makedirs(f"{etc}/https-hostclient")
			args = [ 'hxtool', 'print', '--content',
					f"{prefix}.pem" ]
			log(f"running subprocess: {args}")
			c = subprocess.run(args,
				capture_output = True,
				text = True)
			log(f"- returned {c}")
			resprefix = 'no.hostname.found'
			for l in c.stdout.split('\n'):
				s = l.strip()
				if s.startswith('dNSName: '):
					resprefix = s.replace('dNSName: ', '')
					break
		else:
			d = lazy_makedirs(f"{etc}/{cat}")
			resprefix = subcat
	elif split4[0] == 'user':
		if len(split4) != 4:
			log(f"map_hostcert({prefix}), no user mapping")
			return -1, None, None
		log(f"following 'user' handling")
		cat = split4[1]
		subcat = split4[2]
		origuser = split4[3]
		localuser = usermap(origuser)
		resprefix = f"{subcat}-{localuser}"
		userexists = True
		try:
			pwdinfo = pwd.getpwnam(localuser)
		except KeyError:
			userexists = False
		if userexists:
			log(f"user {localuser} exists")
			pwdirexists = False
			if pwdinfo:
				pwdir = pwdinfo.pw_dir
				pwdirexists = os.path.isdir(pwdir)
			uid = pwdinfo.pw_uid
			if pwdirexists:
				log(f"home dir is {pwdir}")
				if not os.path.isdir(f"{pwdir}/.hcp"):
					os.mkdir(f"{pwdir}/.hcp")
					os.chown(f"{pwdir}/.hcp", uid, -1)
				if not os.path.isdir(f"{pwdir}/.hcp/{cat}"):
					os.mkdir(f"{pwdir}/.hcp/{cat}")
					os.chown(f"{pwdir}/.hcp/{cat}", uid, -1)
				d = f"{pwdinfo.pw_dir}/.hcp/{cat}"
			else:
				log(f"no home dir ({pwdir} doesn't exist)")
				lazy_makedirs(f"{etc}/creds/role")
				if not os.path.isdir(f"{etc}/creds/role/{localuser}"):
					os.mkdir(f"{etc}/creds/role/{localuser}")
					os.chown(f"{etc}/creds/role/{localuser}",
						uid, -1)
				if not os.path.isdir(f"{etc}/creds/role/{localuser}/{cat}"):
					os.mkdir(f"{etc}/creds/role/{localuser}/{cat}")
					os.chown(f"{etc}/creds/role/{localuser}/{cat}",
						uid, -1)
				d = f"{etc}/creds/role/{localuser}/{cat}"
		else:
			log(f"user {localuser} doesn't exist")
			d = lazy_makedirs(f"{etc}/creds/unknown/{localuser}/{cat}")
	else:
		log(f"map_hostcert({prefix}), unrecognized form")
		return -1, None, None
	return uid, d, resprefix

# Installer for host certificates (and keys)
def method_hostcerts(filematch):
	def fn(fname, _class):
		log(f"hostcerts::fn({fname}) starting")
		# The glob matches on both the cert and key files, so we only
		# want to return non-empty when we are called for the cert, and
		# at that point we'll return a list containing the cert and key
		# together.
		if not re_pem_prog.search(fname):
			log("doesn't match pem regex, returning empty")
			return []
		if re_key_prog.search(fname):
			log("matches 'key' regex, returning empty")
			return []
		prefix = re_pem_prog.sub('', fname)
		# Now, we have an arbitrary cert/key pair and want to figure
		# out not just where it should go but also who it should be
		# owned by. Defer this to the map_hostcert() function. Pass it
		# the common prefix to the cert and key, it returns a 3-tuple
		# of uid, directory path and file-prefix.  To the latter we
		# append the '.pem' and '-key.pem' that we removed from the
		# input.
		uid, destpath, destprefix = map_hostcert(prefix)
		res = []
		if uid != -1:
			res = [ {
				'name': f"{prefix}.pem",
				'dest': f"{destpath}/{destprefix}.pem",
				'uid': uid,
				'mode': 0o644
				}, {
				'name': f"{prefix}-key.pem",
				'dest': f"{destpath}/{destprefix}-key.pem",
				'uid': uid,
				'mode': 0o600
				} ]
		log(f"returning {res}")
		return res;
	return {
		'fn': fn,
		'preinstall': lambda assets: gen_preinstall(filematch, assets),
		'postinstall': lambda assets: gen_postinstall(filematch, assets)
	}

# Method for the HCP cert issuer (CA)
def method_certissuer(filematch):
	# This should only be called once, given that our glob is an exact-match.
	def fn(fname, _class):
		log(f"certissuer::fn({fname}) starting")
		bdir = lazy_makedirs(f"/usr/share/ca-certificates/{myid}")
		# The asset record needs name/dest/mode. The top-level loop
		# will supplement it with 'is_changed' before running
		# preinstall and installing the files. Here, we also supplement
		# it with 'already_existed', so our postinstall hook can know
		# whether it's a never-seen-before CA path that needs to be
		# registered in the system's ca-certificates.conf.
		res = [ {
			'name': fname,
			'dest': f"{bdir}/{fname}",
			'mode': 0o644,
			'already_existed': os.path.isfile(f"{bdir}/{fname}") } ]
		log("returning {res}")
		return res;
	def postinstall(assets):
		log(f"certissuer::postinstall starting")
		for x in assets:
			if not x['is_changed']:
				log(f"unchanged {x}")
				continue
			# Rationale: we need to register the file if (and only
			# when) we're installing the file for the first time.
			if not x['already_existed']:
				log(f"new CA {x}")
				with open('/etc/ca-certificates.conf', 'a') as f:
					f.write(f"{myid}/{x['name']}\n")
			else:
				log(f"updated CA {x}")
		log("running 'update-ca-certificates'")
		subprocess.run(['update-ca-certificates'])
		gen_postinstall(filematch, assets)
	return {
		'fn': fn,
		'preinstall': lambda assets: gen_preinstall(filematch, assets),
		'postinstall': postinstall
	}

classes = [
	{
		'_': 'Covers the assets produced by genconf-krb5',
		'name': 'genconf-krb5',
		'glob': 'krb5.conf',
		'method': method_etc('HCP_ATTESTCLIENT_HOOK_KRB5CONF')
	}, {
		'_': 'Covers the assets produced by gencert-hxtool',
		'name': 'gencert-hxtool',
		'glob': 'hostcert-*.pem',
		'method': method_hostcerts('HCP_ATTESTCLIENT_HOOK_HOSTCERTS')
	}, {
		'_': 'Covers the assets produced by gencert-issuer',
		'name': 'gencert-issuer',
		'glob': 'certissuer.pem',
		'method': method_certissuer('HCP_ATTESTCLIENT_HOOK_CA')
	}, {
		'_': 'Covers the assets produced by genkrb5keytab',
		'name': 'genkrb5keytab',
		'glob': 'krb5.keytab',
		'method': method_keytab('HCP_ATTESTCLIENT_HOOK_KRB5KEYTAB')
	}
]

# General processing starts here

print("Processing assets returned from attestation")

log("starting class loop")

for c in classes:
	print(f"Class: {c['name']}")
	meth = c['method']
	matches = glob.glob(c['glob'])
	log(f"class={c['name']}: glob={matches}")
	for fname in matches:
		log(f"fname={fname}")
		items = meth['fn'](fname, c)
		log(f"meth({fname}) -> items={items}")
		if len(items) == 0:
			continue
		anything_changed = False
		log("running the 'what changed' loop")
		for x in items:
			# We augment the asset record with a 'has_changed'
			# attribute, which can be harnessed by the
			# postinstall() hook.
			if not 'uid' in x:
				x['uid'] = 1
			x['is_changed'] = not os.path.isfile(x['dest']) or \
				not filecmp.cmp(x['name'], x['dest']) or \
				pwd.getpwuid(os.stat(x['dest']).st_uid).pw_uid \
					!= x['uid']
			verbose(f" - asset: {x['name']} ({x['mode']:o}) " +
				f"[{x['is_changed'] and 'changed' or 'unchanged'}]")
			anything_changed = anything_changed or x['is_changed']
			log(f"asset={x},anything_changed={anything_changed}")
		if 'preinstall' in meth and meth['preinstall']:
			verbose(f" [preinstall]")
			log(f"calling {meth}'s preinstall hook")
			meth['preinstall'](items)
		if not anything_changed:
			print(f' [no changes]')
		else:
			log("running the 'cp+chmod' loop")
			for x in items:
				log(f"x={x}")
				if x['is_changed']:
					print(f" - install: {x['name']},{x['mode']:o}")
					print(f"      dest: {x['dest']}")
					shutil.copyfile(x['name'], x['dest'])
					os.chmod(x['dest'], x['mode'])
					uid = x['uid']
					if uid != 1:
						os.chown(x['dest'], uid, -1)
		if 'postinstall' in meth and meth['postinstall']:
			verbose(f" [postinstall]")
			meth['postinstall'](items)
