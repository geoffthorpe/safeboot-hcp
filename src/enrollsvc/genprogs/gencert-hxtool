#!/usr/bin/python3

import os
import requests
import subprocess
import sys
import json
from pathlib import Path

import datetime
now = datetime.datetime.now(datetime.timezone.utc)
suffix = f"{now.year:04}:{now.month:02}:{now.day:02}:{now.hour:02}"
tracefile = open(f"{os.environ['HOME']}/debug-hxtool-{suffix}", 'a')
sys.stderr = tracefile

sys.path.insert(1, '/hcp/xtra')
from HcpRecursiveUnion import union

sys.path.insert(1, '/hcp/common')
from hcp_common import log, bail, dict_val_or, dict_pop_or, env_get, env_get_or_none

class HcpErrorGencertHxtool(Exception):
	pass

# attest-enroll sends us 3 arguments (+1 for the program name, so
# len(sys.args)==4), but we only consume the first, the directory to produce
# output to.
if len(sys.argv) <= 3:
	bail(f"Wrong number of arguments: {len(sys.argv)}")

output_dir = sys.argv[1]
if not Path(output_dir).is_dir():
	bail(f"Output location is not a directory: {output_dir}")

policy_url = env_get_or_none('HCP_ENROLLSVC_POLICY')
if policy_url:
	request_uid = env_get('HCP_REQUEST_UID')

# Error-checking? No, if assumptions and requirements aren't met; exceptions.
conf_enroll = json.loads(env_get('ENROLL_JSON'))
conf_env = dict_val_or(conf_enroll, '__env', {})
conf_hxtool = dict_val_or(conf_enroll, 'gencert-hxtool', {})
log(f"gencert-hxtool: {json.dumps(conf_enroll)}")
conf_common = dict_val_or(conf_hxtool, '<common>', {})
certlist = [ x for x in dict_val_or(conf_hxtool, 'list', []) if x != '<common>' ]
certprefix = dict_val_or(conf_hxtool, 'prefix', "")

output_assets_sensitive = []
output_assets_public = []

for asset in certlist:
	log(f"Processing asset={asset}")
	# Each 'asset' from the list of desired certs should have a section
	# in the 'hxtool' config block, it defines the command to run!
	if asset not in conf_hxtool:
		raise HcpErrorGencertHxtool(f"asset {asset} not in JSON {conf_hxtool}")
	conf_asset = union(conf_common, conf_hxtool[asset])
	log(f" - conf_asset={conf_asset}")
	# Keep a copy for the policy check (before conf_asset gets fields popped)
	copy_asset = conf_asset.copy()
	cmd = [ 'hxtool', 'issue-certificate' ]
	# Special handling:
	# - the '--certificate' setting comes from 'name' if defined, otherwise
	#   from 'asset' itself
	# - the '--type' setting comes from 'type' (REQUIRED)
	# - the '--ca-certificate' setting must be part of the profile (REQUIRED)
	# - any non-option args come from 'args' (OPTIONAL)
	# - all other key-value pairs (OPTIONAL) define '--key=value' options
	#   - if value==None ('null' in the original JSON); just '--key'
	if 'certificate' in conf_asset:
		raise HcpErrorGencertHxtool(f"Must not have 'certificate' property!")
	if 'certificate-private-key' in conf_asset:
		raise HcpErrorGencertHxtool(f"Must not have 'certificate-private-key' property!")
	if 'ca-certificate' not in conf_asset:
		raise HcpErrorGencertHxtool(f"Must have 'ca-certificate' property!")
	if 'name' in conf_asset:
		assetname = conf_asset.pop('name')
	else:
		assetname = asset
	assetname_key = f"{certprefix}{assetname}-key.pem"
	cmd += [ f'--certificate={assetname_key}' ]
	cmd += [ f'--type={conf_asset.pop("type")}' ]
	issuer_cert = conf_asset['ca-certificate']
	args = dict_pop_or(conf_asset, 'args', [])
	for prop in conf_asset:
		propval = conf_asset[prop]
		if not propval:
			propvals = []
		elif isinstance(propval, str) or isinstance(propval, int):
			propvals = [ str(propval) ]
		elif isinstance(propval, dict):
			propvals = [ json.dumps(propval) ]
		elif not isinstance(propval, list):
			raise HcpErrorGencertHxtool(
				f"Property {prop} has bad type: {type(propval)}")
		else:
			propvals = propval
		for propval in propvals:
			if not propval:
				cmd += [ f"--{prop}" ]
			elif not isinstance(propval, str):
				raise HcpErrorGencertHxtool(
					f"Property {prop} has bad type: {type(propval)}")
			else:
				cmd += [ f"--{prop}={propval}" ]
	cmd += args
	log(f" - cmd={cmd}")

	# Policy check
	if policy_url:
		log(" - policy_check")
		json_asset = json.dumps({ asset: copy_asset, '__env': conf_env })
		form_data = {
			'hookname': (None, 'enrollsvc::mgmt::asset_check'),
			'request_uid': (None, request_uid),
			'params': (None, json_asset)
		}
		log(f"   - form_data={form_data}")
		response = requests.post(f"{policy_url}/emgmt/gencert-hxtool",
					 files = form_data)
		log(f"   - response={response}")
		if response.status_code != 200:
			bail(f"policy-checker {response.status_code} refused {json_asset}")

	# Run the command "hxtool issue-certificate"
	log(f" - running hxtool command;")
	result = subprocess.run(cmd, cwd = output_dir, text = True,
				stdout = subprocess.PIPE,
				stderr = tracefile)
	log(f" - result={result}")
	if result.returncode != 0:
		bail(f"hxtool command failed {result.returncode}: {cmd}")

	# Run an "openssl x509" command on the asset (key+cert) to extract the
	# public cert to its own file
	assetname_cert = f"{certprefix}{assetname}.pem"
	cmd = [ 'openssl', 'x509', '-inform', 'PEM', '-outform', 'PEM',
		'-in', assetname_key, '-out', assetname_cert ]
	log(f" - running {cmd};")
	result = subprocess.run(cmd, cwd = output_dir, text = True,
				stdout = subprocess.PIPE,
				stderr = tracefile)
	if result.returncode != 0:
		bail(f"openssl command for cert {result.returncode}: {cmd}")

	# Run an "openssl x509" command on the issuer cert (which includes the key)
	# to extract just the cert, that we might append it to the generated asset
	# so it can be chain-verified. NB, the cert goes to stdout, not a file.
	cmd = [ 'openssl', 'x509', '-inform', 'PEM', '-outform', 'PEM',
		'-in', issuer_cert ]
	log(f" - running {cmd};")
	result = subprocess.run(cmd, cwd = output_dir, text = True,
				stdout = subprocess.PIPE,
				stderr = tracefile)
	if result.returncode != 0:
		bail(f"openssl command for issuer failed {result.returncode}: {cmd}")

	# Append the issuer cert to both files for the generated asset
	log(" - appending issuer to key")
	with open(f"{output_dir}/{assetname_key}", "a") as f:
		f.write(result.stdout)
	log(" - appending issuer to cert")
	with open(f"{output_dir}/{assetname_cert}", "a") as f:
		f.write(result.stdout)

	# Declare the generated asset files
	output_assets_sensitive += [ assetname_key ]
	output_assets_public += [ assetname_cert ]

# Finally, our stdout tells the enrollment process what we produced
log(f"output_assets_sensitive={output_assets_sensitive}")
if len(output_assets_sensitive) > 0:
	print(f'sensitive {" ".join(output_assets_sensitive)}')
log(f"output_assets_public={output_assets_public}")
if len(output_assets_public) > 0:
	print(f'public {" ".join(output_assets_public)}')
