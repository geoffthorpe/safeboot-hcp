#!/usr/bin/python3

import os
import subprocess
import sys
import json
from datetime import datetime, timezone, timedelta
from pathlib import Path

sys.path.insert(1, '/hcp/common')
from hcp_common import \
	log, bail, dict_val_or, env_get, \
	dict_timedelta, datetime2hint

# attest-enroll sends us 3 arguments (+1 for the program name, so
# len(sys.args)==4), but we only consume the first, the directory to produce
# output to.
if len(sys.argv) <= 3:
	bail(f"Wrong number of arguments: {len(sys.argv)}")

output_dir = sys.argv[1]
if not Path(output_dir).is_dir():
	bail(f"Output location is not a directory: {output_dir}")

# We generate a hint for "now" + "period". First, what is "now"?
now = datetime.now(timezone.utc)

# Error-checking? No, if assumptions and requirements aren't met; exceptions.
conf_enroll = json.loads(env_get('ENROLL_JSON'))
conf_issuer = dict_val_or(conf_enroll, 'genreenroll', {})
td = dict_timedelta(conf_issuer)
if not td > timedelta():
	bail("Non-zero time period must be provided to genreenroll")

later = now + td

# Convention: we create a "hint-reenroll-YYYYMMDDhhmmss" file for the
# date/time at/after which reenrollment should be triggered. More detail is
# stored in the file, which is a JSON struct with three fields;
#     last: <now>
#     next: <then>
#     seconds: <timedelta>
# <now> and <then> are strings as generated by python's
# datetime.isoformat() method on a 'datetime' object using UTC timezone.
# <timedelta> is an integer. The filename corresponds to the date/time
# expressed in the 'next' field, which should match 'last' + 'seconds'.  In
# this way, a script can use a glob on the hint filenames and sort them to
# get determine what to act on. (I.e. without having to read/parse the
# contents of the hints.)
thenfile = f"hint-reenroll-{datetime2hint(later)}"
thendata = {
	'last': f"{now.isoformat()}",
	'next': f"{later.isoformat()}",
	'seconds': td.seconds
}

with open(f"{output_dir}/{thenfile}", "w") as f:
	json.dump(thendata, f)

print(f"public {thenfile}")
