HCP_DBB_SWTPM_SRC := $(HCP_DEBBUILDER_SRC)/swtpm
HCP_DBB_SWTPM_OUT := $(HCP_DEBBUILDER_OUT)/swtpm
SWTPM_PKG_SRC := $(TOP)/ext-tpmware/swtpm

$(HCP_DBB_SWTPM_OUT): | $(HCP_DEBBUILDER_OUT)
MDIRS += $(HCP_DBB_SWTPM_OUT)

# A wrapper target to build the "dbb_swtpm" image
dbb_swtpm: $(HCP_DBB_SWTPM_OUT)/built
ALL += $(HCP_DBB_SWTPM_OUT)/built

HCP_DBB_SWTPM_DNAME := $(call HCP_IMAGE,dbb_swtpm)
HCP_DBB_SWTPM_TFILE := $(HCP_DBB_SWTPM_OUT)/built
HCP_DBB_SWTPM_DFILE := $(HCP_DBB_SWTPM_OUT)/Dockerfile

# We (currently) derive dbb_swtpm from builder, but we might decide in due
# course to be a sibling rather than descendant.
HCP_DBB_SWTPM_ANCESTOR := HCP_DBB_LIBTPMS
HCP_DBB_SWTPM_ANCESTOR_DNAME := $(call HCP_IMAGE,debbuilder)
HCP_DBB_SWTPM_ANCESTOR_TFILE := $($(HCP_DBB_SWTPM_ANCESTOR)_TFILE)

# We want the build dependencies (from <swtpm-path>/debian/control) to be
# installed.
SWTPM_DEPS := $(shell \
	$(HCP_DEBBUILDER_SRC)/get_build_deps.py \
		"$(SWTPM_PKG_SRC)" \
		"")

# OK, the tricky bit. If swtpm's debian/control file indicates _any_ dependency
# on libtpms (ie. on any of libtpms's packages), we need to replace them it
# with dependencies on _all_ the libtpms packages, by default at least. (We can
# subsequently remove any specific libtpms packages we _don't_ want.) Otherwise
# we get trouble, because the debian/control might only indicate a single
# libtpms package as a dependency because the author knows that'll pull in
# others by dependency - yet in the case of local package builds, we would want
# those others to be pulled from local builds too rather than upstream versions
# (which might otherwise happen). That's why we have this;
$(if $(filter $(libtpms_PKGS),$(SWTPM_DEPS)),\
$(eval SWTPM_DEPS := $(libtpms_PKGS) $(filter-out $(libtpms_PKGS),$(SWTPM_DEPS))))

SWTPM_CLEANUP_PKGS :=
SWTPM_TFILE_DEPS :=
$(eval $(call hcp_dbb,\
	$(SWTPM_DEPS),\
	$(HCP_DBB_SWTPM_OUT),\
	SWTPM_CLEANUP_PKGS,\
	SWTPM_TFILE_DEPS))

SWTPM_DBB_DFILE := $(HCP_DBB_SWTPM_OUT)/dbb.Dockerfile
SWTPM_DBB_ENVS := { \"DEPS\": \"$(SWTPM_DEPS)\"
$(foreach d,$(SWTPM_DEPS),\
$(if $($d_LOCAL_FILE),\
$(eval SWTPM_DBB_ENVS += , \"$d_LOCAL_FILE\" : \"$($d_LOCAL_FILE)\")))
SWTPM_DBB_ENVS += }
$(SWTPM_DBB_DFILE): | $(HCP_DBB_SWTPM_OUT)
$(SWTPM_DBB_DFILE):
	$Qecho "# auto-generated by debbuilder/Makefile" > $@
	$Qecho "$(SWTPM_DBB_ENVS)" | \
		$(HCP_DEBBUILDER_SRC)/produce_dockerfile_stub.py > $@

$(HCP_DBB_SWTPM_DFILE): | $(HCP_DBB_SWTPM_OUT)
$(HCP_DBB_SWTPM_DFILE): $(HCP_DBB_SWTPM_SRC)/Makefile
$(HCP_DBB_SWTPM_DFILE): $(HCP_DBB_SWTPM_SRC)/Dockerfile
$(HCP_DBB_SWTPM_DFILE): $(SWTPM_DBB_DFILE)
$(HCP_DBB_SWTPM_DFILE):
	$Qecho "FROM $(HCP_DBB_SWTPM_ANCESTOR_DNAME)" > $@
	$Qcat $(SWTPM_DBB_DFILE) >> $@
	$Qcat $(HCP_DBB_SWTPM_SRC)/Dockerfile >> $@

$(HCP_DBB_SWTPM_TFILE): $(HCP_DBB_SWTPM_DFILE)
$(HCP_DBB_SWTPM_TFILE): $(HCP_DBB_SWTPM_ANCESTOR_TFILE)
$(HCP_DBB_SWTPM_TFILE): $(SWTPM_TFILE_DEPS)
$(HCP_DBB_SWTPM_TFILE):
	$Qecho "Building container image $(HCP_DBB_SWTPM_DNAME)"
	$Qdocker build -t $(HCP_DBB_SWTPM_DNAME) \
	               -f $(HCP_DBB_SWTPM_DFILE) \
	               $(HCP_DBB_SWTPM_OUT)
	$Qtouch $@
$(eval $(call pp_rule_docker_image_rm,\
	$(HCP_DBB_SWTPM_TFILE),\
	$(HCP_DBB_SWTPM_DNAME),\
	dbb_swtpm,\
	clean_dbb_swtpm))

# Cleanup
ifneq (,$(wildcard $(HCP_DBB_SWTPM_OUT)))
clean_dbb_swtpm: | preclean
	$Qrm -f $(HCP_DBB_SWTPM_DFILE) $(HCP_DBB_SWTPM_TFILE) \
		$(SWTPM_DBB_DFILE) $(SWTPM_CLEANUP_PKGS)
	$Qrmdir $(HCP_DBB_SWTPM_OUT)
clean_dbb_libtpms: clean_dbb_swtpm
endif

# The above is all about the container image for building+packaging swtpm.
# The below is all about building and packaging swtpm.

HCP_DBB_SWTPM_PKG_OUT := $(HCP_DBB_SWTPM_OUT)/artifacts
HCP_DBB_SWTPM_PKG_MOUNT := $(HCP_DBB_SWTPM_PKG_OUT)/swtpm
$(HCP_DBB_SWTPM_PKG_OUT): | $(HCP_DBB_SWTPM_OUT)
$(HCP_DBB_SWTPM_PKG_MOUNT): | $(HCP_DBB_SWTPM_PKG_OUT)
MDIRS += $(HCP_DBB_SWTPM_PKG_OUT) $(HCP_DBB_SWTPM_PKG_MOUNT)
HCP_DBB_SWTPM_PKG_BOOTSTRAPPED := $(HCP_DBB_SWTPM_PKG_OUT)/_bootstrapped
HCP_DBB_SWTPM_PKG_PACKAGED := $(HCP_DBB_SWTPM_PKG_OUT)/_packaged

deb_swtpm: $(HCP_DBB_SWTPM_PKG_PACKAGED)
ALL += $(HCP_DBB_SWTPM_PKG_PACKAGED)

SWTPM_PKG_REFFILE := ./autogen.sh
SWTPM_PKG_CMD_BOOTSTRAP := NOCONFIGURE=1 ./autogen.sh
SWTPM_PKG_CMD_PACKAGE := dpkg-buildpackage -uc -us

# This should match swtpm/configure.ac: "AC_INIT([swtpm],[0.8.0])"
SWTPM_VERSION ?= 0.8.0
# This should match .... actually I can't find it anywhere in swtpm!?
SWTPM_RELEASE ?= ~dev1
# This should match the build architecture
SWTPM_ARCH ?= amd64

# When using 'builder' there is a tarball "package" for each codebase that
# contains a full installation (libraries, tools, debug symbols, etc). When
# using 'debbuilder' or upstream packages, things are divided into distinct
# packages, and you may select from among them. So long as the 'builder'
# mechanism sticks around (and the 'app' layer continutes to explicitly declare
# 'builder'-scope codebases that should be installed in their images), we need
# to know what debian packages should be installed if we are using 'debbuilder'
# or upstream packages. I.e. if the "swtpm" codebase is installed in an
# image, but swtpm is provided by debian packages, the individual packages
# are given by $(swtpm_CANONICAL).
swtpm_PKGS := swtpm swtpm-libs swtpm-dbgsym swtpm-dev swtpm-tools swtpm-tools-dbgsym
swtpm_CANONICAL := swtpm swtpm-libs swtpm-tools
$(foreach p,$(swtpm_PKGS),\
$(eval $p_TFILE := $(HCP_DBB_SWTPM_PKG_PACKAGED))\
$(eval $p_LOCAL_FILE := $p_$(SWTPM_VERSION)$(SWTPM_RELEASE)_$(SWTPM_ARCH).deb)\
$(eval $p_LOCAL_PATH := $(HCP_DBB_SWTPM_PKG_OUT)/$($p_LOCAL_FILE)))

HCP_DBB_LIST += $(swtpm_PKGS)

SWTPM_PKG_DOCKERCMD := \
		docker run --rm -v $(HCP_DBB_SWTPM_PKG_OUT):/empty \
		-v $(SWTPM_PKG_SRC):/empty/swtpm \
		$(HCP_DBB_SWTPM_DNAME) \
		bash -c
SWTPM_PKG_CHOWN := \
		trap '/hcp/base/chowner.sh $(SWTPM_PKG_REFFILE) ..' EXIT ; \
		cd /empty/swtpm

# The bootstrapped target is only used as an order-only dependency, meaning it
# won't get _explicitly_ bootstrapped again until a "make clean_<something>"
# removes our touchfile.  OTOH, once bootstrapped, autotools set things up so
# that a rebuild (dpkg-buildpackage) should re-bootstrap if and when necessary.
$(HCP_DBB_SWTPM_PKG_BOOTSTRAPPED): $(HCP_DBB_SWTPM_TFILE)
$(HCP_DBB_SWTPM_PKG_BOOTSTRAPPED): | $(HCP_DBB_SWTPM_PKG_MOUNT)
$(HCP_DBB_SWTPM_PKG_BOOTSTRAPPED):
	$Q$(SWTPM_PKG_DOCKERCMD) \
		"$(SWTPM_PKG_CHOWN) ; $(SWTPM_PKG_CMD_BOOTSTRAP)"
	$Qtouch $@

# We create a dependency for package-building on the most recent file in the
# source tree, hence the complex 'find' command
$(HCP_DBB_SWTPM_PKG_PACKAGED): | $(HCP_DBB_SWTPM_PKG_BOOTSTRAPPED)
$(HCP_DBB_SWTPM_PKG_PACKAGED): $(shell \
	find $(SWTPM_PKG_SRC) -type f -printf '%T@ %p\n' | \
	sort -n | tail -1 | cut -f2- -d" ")
$(HCP_DBB_SWTPM_PKG_PACKAGED):
	$Q$(SWTPM_PKG_DOCKERCMD) \
		"$(SWTPM_PKG_CHOWN) ; $(SWTPM_PKG_CMD_PACKAGE)"
	$Qtouch $@

ifneq (,$(wildcard $(HCP_DBB_SWTPM_PKG_OUT)))
clean_dbb_swtpm_artifacts:
	$Qif test -d $(HCP_DBB_SWTPM_PKG_MOUNT); then \
		rmdir $(HCP_DBB_SWTPM_PKG_MOUNT); \
	fi
	$Qrm -f $(HCP_DBB_SWTPM_PKG_OUT)/*
	$Qrmdir $(HCP_DBB_SWTPM_PKG_OUT)
clean_dbb_swtpm: clean_dbb_swtpm_artifacts
endif
