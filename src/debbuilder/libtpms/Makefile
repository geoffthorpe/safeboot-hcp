HCP_DBB_LIBTPMS_SRC := $(HCP_DEBBUILDER_SRC)/libtpms
HCP_DBB_LIBTPMS_OUT := $(HCP_DEBBUILDER_OUT)/libtpms
LIBTPMS_PKG_SRC := $(TOP)/ext-tpmware/libtpms

$(HCP_DBB_LIBTPMS_OUT): | $(HCP_DEBBUILDER_OUT)
MDIRS += $(HCP_DBB_LIBTPMS_OUT)

# A wrapper target to build the "dbb_libtpms" image
dbb_libtpms: $(HCP_DBB_LIBTPMS_OUT)/built
ALL += $(HCP_DBB_LIBTPMS_OUT)/built

HCP_DBB_LIBTPMS_DNAME := $(call HCP_IMAGE,dbb_libtpms)
HCP_DBB_LIBTPMS_TFILE := $(HCP_DBB_LIBTPMS_OUT)/built
HCP_DBB_LIBTPMS_DFILE := $(HCP_DBB_LIBTPMS_OUT)/Dockerfile

# We (currently) derive dbb_libtpms from builder, but we might decide in due
# course to be a sibling rather than descendant.
HCP_DBB_LIBTPMS_ANCESTOR := HCP_DEBBUILDER
HCP_DBB_LIBTPMS_ANCESTOR_DNAME := $(call HCP_IMAGE,debbuilder)
HCP_DBB_LIBTPMS_ANCESTOR_TFILE := $($(HCP_DBB_LIBTPMS_ANCESTOR)_TFILE)

# We want the build dependencies (from <libtpms-path>/debian/control) to be
# installed.
LIBTPMS_DEPS := $(shell \
	$(HCP_DEBBUILDER_SRC)/get_build_deps.py \
		"$(LIBTPMS_PKG_SRC)" \
		"")

LIBTPMS_CLEANUP_PKGS :=
LIBTPMS_TFILE_DEPS :=
$(eval $(call hcp_dbb,\
	$(LIBTPMS_DEPS),\
	$(HCP_DBB_LIBTPMS_OUT),\
	LIBTPMS_CLEANUP_PKGS,\
	LIBTPMS_TFILE_DEPS))

LIBTPMS_DBB_DFILE := $(HCP_DBB_LIBTPMS_OUT)/dbb.Dockerfile
LIBTPMS_DBB_ENVS := { \"DEPS\": \"$(LIBTPMS_DEPS)\"
$(foreach d,$(LIBTPMS_DEPS),\
$(if $($d_LOCAL_FILE),\
$(eval LIBTPMS_DBB_ENVS += , \"$d_LOCAL_FILE\" : \"$($d_LOCAL_FILE)\")))
LIBTPMS_DBB_ENVS += }
$(LIBTPMS_DBB_DFILE): | $(HCP_DBB_LIBTPMS_OUT)
$(LIBTPMS_DBB_DFILE):
	$Qecho "# auto-generated by debbuilder/Makefile" > $@
	$Qecho "$(LIBTPMS_DBB_ENVS)" | \
		$(HCP_DEBBUILDER_SRC)/produce_dockerfile_stub.py >> $@

$(HCP_DBB_LIBTPMS_DFILE): | $(HCP_DBB_LIBTPMS_OUT)
$(HCP_DBB_LIBTPMS_DFILE): $(HCP_DBB_LIBTPMS_SRC)/Makefile
$(HCP_DBB_LIBTPMS_DFILE): $(HCP_DBB_LIBTPMS_SRC)/Dockerfile
$(HCP_DBB_LIBTPMS_DFILE): $(LIBTPMS_DBB_DFILE)
$(HCP_DBB_LIBTPMS_DFILE):
	$Qecho "FROM $(HCP_DBB_LIBTPMS_ANCESTOR_DNAME)" > $@
	$Qcat $(LIBTPMS_DBB_DFILE) >> $@
	$Qcat $(HCP_DBB_LIBTPMS_SRC)/Dockerfile >> $@

$(HCP_DBB_LIBTPMS_TFILE): $(HCP_DBB_LIBTPMS_DFILE)
$(HCP_DBB_LIBTPMS_TFILE): $(HCP_DBB_LIBTPMS_ANCESTOR_TFILE)
$(HCP_DBB_LIBTPMS_TFILE): $(LIBTPMS_TFILE_DEPS)
$(HCP_DBB_LIBTPMS_TFILE):
	$Qecho "Building container image $(HCP_DBB_LIBTPMS_DNAME)"
	$Qdocker build -t $(HCP_DBB_LIBTPMS_DNAME) \
	               -f $(HCP_DBB_LIBTPMS_DFILE) \
	               $(HCP_DBB_LIBTPMS_OUT)
	$Qtouch $@
$(eval $(call pp_rule_docker_image_rm,\
	$(HCP_DBB_LIBTPMS_TFILE),\
	$(HCP_DBB_LIBTPMS_DNAME),\
	dbb_libtpms,\
	clean_dbb_libtpms))

# Cleanup
ifneq (,$(wildcard $(HCP_DBB_LIBTPMS_OUT)))
clean_dbb_libtpms: | preclean
	$Qrm -f $(HCP_DBB_LIBTPMS_DFILE) $(HCP_DBB_LIBTPMS_TFILE) \
		$(LIBTPMS_DBB_DFILE) $(LIBTPMS_CLEANUP_PKGS)
	$Qrmdir $(HCP_DBB_LIBTPMS_OUT)
clean_debbuilder: clean_dbb_libtpms
endif

# The above is all about the container image for building+packaging libtpms.
# The below is all about building and packaging libtpms.

HCP_DBB_LIBTPMS_PKG_OUT := $(HCP_DBB_LIBTPMS_OUT)/artifacts
HCP_DBB_LIBTPMS_PKG_MOUNT := $(HCP_DBB_LIBTPMS_PKG_OUT)/libtpms
$(HCP_DBB_LIBTPMS_PKG_OUT): | $(HCP_DBB_LIBTPMS_OUT)
$(HCP_DBB_LIBTPMS_PKG_MOUNT): | $(HCP_DBB_LIBTPMS_PKG_OUT)
MDIRS += $(HCP_DBB_LIBTPMS_PKG_OUT) $(HCP_DBB_LIBTPMS_PKG_MOUNT)
HCP_DBB_LIBTPMS_PKG_BOOTSTRAPPED := $(HCP_DBB_LIBTPMS_PKG_OUT)/_bootstrapped
HCP_DBB_LIBTPMS_PKG_PACKAGED := $(HCP_DBB_LIBTPMS_PKG_OUT)/_packaged

deb_libtpms: $(HCP_DBB_LIBTPMS_PKG_PACKAGED)
ALL += $(HCP_DBB_LIBTPMS_PKG_PACKAGED)

LIBTPMS_PKG_REFFILE := ./autogen.sh
LIBTPMS_PKG_CMD_BOOTSTRAP := NOCONFIGURE=1 ./autogen.sh
LIBTPMS_PKG_CMD_PACKAGE := dpkg-buildpackage -uc -us

# This should match libtpms/configure.ac: "AC_INIT([libtpms],[0.10.0])"
LIBTPMS_VERSION ?= 0.10.0
# This should match libtpms/dist/libtpms.spec.in: "%define release 0~dev1"
LIBTPMS_RELEASE ?= ~dev1
# This should match the build architecture
LIBTPMS_ARCH ?= amd64

# When using 'builder' there is a tarball "package" for each codebase that
# contains a full installation (libraries, tools, debug symbols, etc). When
# using 'debbuilder' or upstream packages, things are divided into distinct
# packages, and you may select from among them. So long as the 'builder'
# mechanism sticks around (and the 'app' layer continutes to explicitly declare
# 'builder'-scope codebases that should be installed in their images), we need
# to know what debian packages should be installed if we are using 'debbuilder'
# or upstream packages. I.e. if the "libtpms" codebase is installed in an
# image, but libtpms is provided by debian packages, the individual packages
# are given by $(libtpms_CANONICAL).
libtpms_PKGS := libtpms0 libtpms0-dbgsym libtpms-dev
libtpms_CANONICAL := libtpms0
$(foreach p,$(libtpms_PKGS),\
$(eval $p_TFILE := $(HCP_DBB_LIBTPMS_PKG_PACKAGED))\
$(eval $p_LOCAL_FILE := $p_$(LIBTPMS_VERSION)$(LIBTPMS_RELEASE)_$(LIBTPMS_ARCH).deb)\
$(eval $p_LOCAL_PATH := $(HCP_DBB_LIBTPMS_PKG_OUT)/$($p_LOCAL_FILE)))

HCP_DBB_LIST += $(libtpms_PKGS)

LIBTPMS_PKG_DOCKERCMD := \
		docker run --rm -v $(HCP_DBB_LIBTPMS_PKG_OUT):/empty \
		-v $(LIBTPMS_PKG_SRC):/empty/libtpms \
		$(HCP_DBB_LIBTPMS_DNAME) \
		bash -c
LIBTPMS_PKG_CHOWN := \
		trap '/hcp/base/chowner.sh $(LIBTPMS_PKG_REFFILE) ..' EXIT ; \
		cd /empty/libtpms

# The bootstrapped target is only used as an order-only dependency, meaning it
# won't get _explicitly_ bootstrapped again until a "make clean_<something>"
# removes our touchfile.  OTOH, once bootstrapped, autotools set things up so
# that a rebuild (dpkg-buildpackage) should re-bootstrap if and when necessary.
$(HCP_DBB_LIBTPMS_PKG_BOOTSTRAPPED): $(HCP_DBB_LIBTPMS_TFILE)
$(HCP_DBB_LIBTPMS_PKG_BOOTSTRAPPED): | $(HCP_DBB_LIBTPMS_PKG_MOUNT)
$(HCP_DBB_LIBTPMS_PKG_BOOTSTRAPPED):
	$Q$(LIBTPMS_PKG_DOCKERCMD) \
		"$(LIBTPMS_PKG_CHOWN) ; $(LIBTPMS_PKG_CMD_BOOTSTRAP)"
	$Qtouch $@

# We create a dependency for package-building on the most recent file in the
# source tree, hence the complex 'find' command
$(HCP_DBB_LIBTPMS_PKG_PACKAGED): | $(HCP_DBB_LIBTPMS_PKG_BOOTSTRAPPED)
$(HCP_DBB_LIBTPMS_PKG_PACKAGED): $(shell \
	find $(LIBTPMS_PKG_SRC) -type f -printf '%T@ %p\n' | \
	sort -n | tail -1 | cut -f2- -d" ")
$(HCP_DBB_LIBTPMS_PKG_PACKAGED):
	$Q$(LIBTPMS_PKG_DOCKERCMD) \
		"$(LIBTPMS_PKG_CHOWN) ; $(LIBTPMS_PKG_CMD_PACKAGE)"
	$Qtouch $@

ifneq (,$(wildcard $(HCP_DBB_LIBTPMS_PKG_OUT)))
clean_dbb_libtpms_artifacts:
	$Qif test -d $(HCP_DBB_LIBTPMS_PKG_MOUNT); then \
		rmdir $(HCP_DBB_LIBTPMS_PKG_MOUNT); \
	fi
	$Qrm -f $(HCP_DBB_LIBTPMS_PKG_OUT)/*
	$Qrmdir $(HCP_DBB_LIBTPMS_PKG_OUT)
clean_dbb_libtpms: clean_dbb_libtpms_artifacts
endif
