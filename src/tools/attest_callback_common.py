#!/usr/bin/python3

import glob
import subprocess
import shutil
import os
import sys
import re
import filecmp
import json

sys.path.insert(1, '/hcp/common')
to_trace = 'HCP_NO_TRACE' not in os.environ
if to_trace:
	from hcp_tracefile import tracefile
	tfile = tracefile(f"attest_callback")
	sys.stderr = tfile
else:
	tfile = sys.stderr
import hcp_common
log = hcp_common.log
bail = hcp_common.bail

if 'VERBOSE' in os.environ:
	def verbose(s):
		print(s)
else:
	def verbose(s):
		pass

# This callback, if registered in HCP_ATTESTCLIENT_CALLBACKS, serves to hoover
# up various assets generated by enrollsvc "genprogs" and perform some kind of
# standard/common treatment.
#
# For any assets that should get more specific handling than what is done here,
# callbacks should be defined to do that work and they should be listed in
# HCP_ATTESTCLIENT_CALLBACKS earlier than this one (to ensure it runs before
# hand). If those callbacks leave those assets in the source (current)
# directory when exiting, then this callback will still pick up on them and
# perform the standard treatment. To avoid this, those callbacks should remove
# the source assets before exiting.

log("Starting attest_callback_common")

# Generic pre/post hook handling. If "{envprefix}_PRE" or "{envprefix}_POST"
# are defined (in the environment), their values are interpreted as executable
# paths that shoud be run if any of this asset's files have changed in the
# enrollment received from the last attestation. A JSON presentation of the
# 'assets' array will written to the process's stdin. An example of the format
# is here, and note that at least one of the booleans will be true. (This would
# occur, for example, when automatic reenrollment occurs, meaning that a new
# certificate might be issued for the same/unchanging private key.)
#    [
#        ( "/etc/ssl/hostcerts/hostcert-foo-bar.pem", True),
#        ( "/etc/ssl/hostcerts/hostcert-foo-bar-key.pem", False)
#    ]
def gen_preinstall(envprefix, assets):
	if envprefix and f"{envprefix}_PRE" in os.environ:
		prog = os.environ[f"{envprefix}_PRE"]
		subprocess.run([prog, fname], text = True,
				input = json.dumps(assets))
def gen_postinstall(envpostfix, assets):
	if envpostfix and f"{envpostfix}" in os.environ:
		prog = os.environ[f"{envpostfix}"]
		subprocess.run([prog, fname], text = True,
				input = json.dumps(assets))

# Method for assets that need typical /etc/<foo> handling
def method_etc(envprefix):
	return {
		# This method belongs to a 'class' that already has a glob
		# pattern to identify files of interest in the current
		# directory (a temp extraction of the enrollment data). For
		# each filename, it calls this 'fn' handler. The return from
		# the handler is a list/array of zero or more asset records,
		# called an 'asset bundle'. 'fn' may examine the files passed
		# to it to determine their relevance or may not need to. And
		# for any given invocation, 'fn' may return an empty list - eg.
		# when the file is to be ignored, or if it is part of an
		# asset-bundle and you only want to return that list when 'fn'
		# is invoked for a particular 'leader' file in the bundle. (Eg.
		# perhaps the glob matches on multiple files for the same
		# bundle, and you want to ensure 'fn' only returns non-empty
		# for one of them.) Also, the subsequent preinstall/postinstall
		# hooks get called once per asset bundle, so you want 'fn' to
		# triage the filenames it gets called for (based on that glob)
		# and (only) return a list of filenames (only) when
		# appropriate.
		# - inputs: filename, the handler using this method
		# - outputs: arbitrary-length (and possibly-empty) array of
		#            dicts: (fname, dest_path, chmod_mode)
		'fn': lambda fname, _class: [ {
			'name': fname,
			'dest': f"/etc/{fname}",
			'mode': 0o644 } ],
		# (Optional) hook to run before installing. This runs once for
		# each asset-bundle that 'fn' returns.
		# - input: list/array of asset records (same dicts as those
		#   returned from 'fn', but with a boolean-valued 'is_changed'
		#   added to it)
		'preinstall': lambda assets: gen_preinstall(envprefix, assets),
		# (Optional) like preinstall, but run after installing.
		'postinstall': lambda assets: gen_postinstall(envprefix, assets)
	}

# Installer for host certificates (and keys)
re_pem_prog = re.compile('\\.pem$')
re_key_prog = re.compile('-key\\.pem$')
def method_hostcerts(envprefix):
	bdir = '/etc/ssl/hostcerts'
	def fn(fname, _class):
		log(f"hostcerts::fn({fname}) starting")
		# The glob matches on both the cert and key files, so we only
		# want to return non-empty when we are called for the cert, and
		# at that point we'll return a list containing the cert and key
		# together.
		if not re_pem_prog.search(fname):
			log("doesn't match pem regex, returning empty")
			return []
		if re_key_prog.search(fname):
			log("matches 'key' regex, returning empty")
			return []
		keyname = re_pem_prog.sub('-key.pem', fname)
		fullcert = f"{bdir}/{fname}"
		fullkey = f"{bdir}/{keyname}"
		if not os.path.isdir(bdir):
			log("lazy initialization of '{bdir}'")
			os.mkdir(bdir)
		res = [ {
				'name': fname,
				'dest': fullcert,
				'mode': 0o644
			}, {
				'name': keyname,
				'dest': fullkey,
				'mode': 0o600
			} ]
		log("returning {res}")
		return res;
	return {
		'fn': fn,
		'preinstall': lambda assets: gen_preinstall(envprefix, assets),
		'postinstall': lambda assets: gen_postinstall(envprefix, fname)
	}

# Method for the HCP cert issuer (CA)
def method_certissuer(envprefix):
	# This should only be called once, given that our glob is an exact-match.
	def fn(fname, _class):
		log(f"certissuer::fn({fname}) starting")
		bdir = f"/usr/share/ca-certificates/HCP"
		if not os.path.isdir(bdir):
			log("lazy initialization of '{bdir}'")
			os.mkdir(bdir)
		# The asset record needs name/dest/mode. The top-level loop
		# will supplement it with 'is_changed' before running
		# preinstall and installing the files. Here, we also supplement
		# it with 'already_existed', so our postinstall hook can know
		# whether it's a never-seen-before CA path that needs to be
		# registered in the system's ca-certificates.conf.
		res = [ {
			'name': fname,
			'dest': f"{bdir}/{fname}",
			'mode': 0o644,
			'already_existed': os.path.isfile(f"{bdir}/{fname}") } ]
		log("returning {res}")
		return res;
	def postinstall(assets):
		log(f"certissuer::postinstall starting")
		for x in assets:
			if not x['is_changed']:
				log(f"unchanged {x}")
				continue
			# Rationale: we need to register the file if (and only
			# when) we're installing the file for the first time.
			if not x['already_existed']:
				log(f"new CA {x}")
				with open('/etc/ca-certificates.conf', 'a') as f:
					f.write(f"HCP/{x['name']}\n")
			else:
				log(f"updated CA {x}")
		log("running 'update-ca-certificates'")
		subprocess.run(['update-ca-certificates'])
		gen_postinstall(envprefix, assets)
	return {
		'fn': fn,
		'preinstall': lambda assets: gen_preinstall(envprefix, assets),
		'postinstall': postinstall
	}

classes = [
	{
		'_': 'Covers the assets produced by genconf-krb5',
		'name': 'genconf-krb5',
		'glob': 'krb5.conf',
		'method': method_etc('HCP_ATTESTCLIENT_HOOK_KRB5CONF')
	}, {
		'_': 'Covers the assets produced by gencert-hxtool',
		'name': 'gencert-hxtool',
		'glob': 'hostcert-*.pem',
		'method': method_hostcerts('HCP_ATTESTCLIENT_HOOK_HOSTCERT')
	}, {
		'_': 'Covers the assets produced by gencert-issuer',
		'name': 'gencert-issuer',
		'glob': 'certissuer.pem',
		'method': method_certissuer('HCP_ATTESTCLIENT_HOOK_CA')
	}, {
		'_': 'Covers the assets produced by genkrb5keytab',
		'name': 'genkrb5keytab',
		'glob': 'krb5.keytab',
		'method': method_etc('HCP_ATTESTCLIENT_HOOK_KRB5KEYTAB')
	}
]

# General processing starts here

print("Processing assets returned from attestation")

log("starting class loop")

for c in classes:
	print(f"Class: {c['name']}")
	meth = c['method']
	matches = glob.glob(c['glob'])
	log(f"class=c['name']: glob={matches}")
	for fname in matches:
		items = meth['fn'](fname, c)
		log(f"fname={fname}: items={items}")
		if len(items) == 0:
			continue
		anything_changed = False
		log("running the 'what changed' loop")
		for x in items:
			# We augment the asset record with a 'has_changed' attribute, which
			# can be harnessed by the postinstall() hook.
			x['is_changed'] = not os.path.isfile(x['dest']) or \
					not filecmp.cmp(x['name'], x['dest'])
			verbose(f" - asset: {x['name']} ({x['mode']:o}) " +
				f"[{x['is_changed'] and 'changed' or 'unchanged'}]")
			anything_changed = anything_changed or x['is_changed']
			log(f"asset={x},anything_changed={anything_changed}")
		if not anything_changed:
			print(f' [no changes]')
			continue
		if 'preinstall' in meth and meth['preinstall']:
			verbose(f" [preinstall]")
			log(f"calling {meth}'s preinstall hook")
			meth['preinstall'](items)
		log("running the 'cp+chmod' loop")
		for x in items:
			log(f"x={x}")
			if x['is_changed']:
				print(f" - install: {x['name']},{x['mode']:o}")
				shutil.copyfile(x['name'], x['dest'])
				os.chmod(x['dest'], x['mode'])
		if 'postinstall' in meth and meth['postinstall']:
			verbose(f" [postinstall]")
			meth['postinstall'](items)
