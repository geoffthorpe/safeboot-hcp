# $1 - name of the image (can be referred to later as $(call HCP_IMAGE,<name>))
# $2 - ancestor image;
#      - SYM:<symbol>, if it should derive from HCP_<symbol>_DNAME using
#        HCP_<symbol>_TFILE for dependencies, or
#      - EXT:<basename>, if it should derive from <basename>, without
#        dependencies, or
#      - <name>, if the ancestor was also defined by app_image(), or
#      - empty, if it should derive from base-platform,
# $3 - source packages to inject
# $4 - if non-empty, provides args for an ENTRYPOINT command in the Dockerfile
# $5 - if non-empty, provides args for a CMD command in the Dockerfile
define app_image

$(eval LOCAL_NAME := $(strip $1))
$(eval LOCAL_ANAME := app_$(LOCAL_NAME))
$(eval LOCAL_DNAME := $(call HCP_IMAGE,$(LOCAL_NAME)))
$(eval HCP_$(LOCAL_NAME)_DNAME := $(LOCAL_DNAME))
$(eval LOCAL_CTX := $(HCP_APPS_OUT)/$(LOCAL_NAME))
$(eval HCP_$(LOCAL_NAME)_CTX := $(LOCAL_CTX))
$(eval LOCAL_CTX_TFILE := $(LOCAL_CTX)/_assembled)
$(eval LOCAL_DFILE := $(LOCAL_CTX)/Dockerfile)
$(eval LOCAL_DFILE_INPUTS :=)
$(eval LOCAL_TFILE := $(LOCAL_CTX)/_built)
$(eval HCP_$(LOCAL_NAME)_TFILE := $(LOCAL_TFILE))
$(eval HCP_$(LOCAL_NAME)_DFILE := $(LOCAL_DFILE))
$(eval LOCAL_ANCESTOR := $(strip $2))
$(eval LOCAL_EXTBASENAME := $(patsubst EXT:%,%,$(filter EXT:%,$(LOCAL_ANCESTOR))))
$(eval LOCAL_EXTBASE_TFILE :=)
$(eval LOCAL_SYMBASENAME := $(patsubst SYM:%,%,$(filter SYM:%,$(LOCAL_ANCESTOR))))
$(if $(LOCAL_SYMBASENAME),\
$(eval LOCAL_ANCESTOR_TFILE := $(HCP_$(LOCAL_SYMBASENAME)_TFILE))\
$(eval LOCAL_ANCESTOR := $(HCP_$(LOCAL_SYMBASENAME)_DNAME))\
,
$(if $(LOCAL_EXTBASENAME),\
$(eval LOCAL_EXTBASE_TFILE := $(LOCAL_CTX)/_extpulled)
$(eval LOCAL_ANCESTOR_TFILE := $(LOCAL_EXTBASE_TFILE))\
$(eval LOCAL_ANCESTOR := $(LOCAL_EXTBASENAME))\
,\
$(if $(LOCAL_ANCESTOR),\
$(eval HCP_$(LOCAL_NAME)_DEP := $(LOCAL_ANCESTOR))\
$(eval HCP_$(LOCAL_ANCESTOR)_DEPENDEES += $(LOCAL_NAME))\
$(eval LOCAL_ANCESTOR_TFILE := $(HCP_$(LOCAL_ANCESTOR)_TFILE))\
$(eval LOCAL_ANCESTOR := $(call HCP_IMAGE,$(LOCAL_ANCESTOR)))\
,\
$(eval LOCAL_ANCESTOR_TFILE := $(HCP_BASE_TFILE))\
$(eval LOCAL_ANCESTOR := $(HCP_BASE_DNAME))\
)))
$(eval LOCAL_PKGS := $(strip $3))
$(eval LOCAL_DFILE_ENTRYPOINT := $(strip $4))
$(eval LOCAL_DFILE_CMD := $(strip $5))

$(eval APPS_NAMES += $(LOCAL_NAME))

# Output directory created ("./output/apps/<foo>")
$(LOCAL_CTX): | $(HCP_APPS_OUT)
MDIRS += $(LOCAL_CTX)

# Symbolic target ("make app_<foo>")
$(LOCAL_ANAME): $(LOCAL_TFILE)

# Touchfile when fully built ("./output/apps/<foo>/_built"), depends;
# - output directory contents up to date (CTX_FILE)
# - parent container image up to date (ANCESTOR_TFILE)
$(LOCAL_TFILE): $(LOCAL_CTX_TFILE)
$(LOCAL_TFILE): $(LOCAL_ANCESTOR_TFILE)
$(LOCAL_TFILE):
	$Qecho "Building $(LOCAL_DNAME) container image"
	$Qdocker build \
		-t $(LOCAL_DNAME) \
		-f $(LOCAL_DFILE) \
		$(LOCAL_CTX)
	$Qtouch $$@

# Output directory populated ("./output/apps/<foo>/_assembled"), depends;
# - Dockerfile up to date (DFILE)
# - all package (tarball) hard links are up to date (these deps are added in
#   the per-package loop further down)
$(LOCAL_CTX_TFILE): $(LOCAL_DFILE)
$(LOCAL_CTX_TFILE):
	$Qtouch $$@

# Dockerfile generated ("./output/apps/<foo>/Dockerfile"), depends;
# - output directory created ("|" CTX)
# - all per-package "hcp.Dockerfile" files (these deps are added in the
#   per-package loop further down)
# The rule for this target is implemented after the per-package loop
$(LOCAL_DFILE): | $(LOCAL_CTX)

# Per-package loop
# - if the package has a "hcp.Dockerfile", it will form part of the
#   LOCAL_DFILE, so declare a dependency accordingly (also remember this
#   in LOCAL_DFILE_INPUTS to implement Dockerfile-generation)
#   - EXCEPTION: this is skipped if an EXT:<basename> is used, because we
#     have no way to know if DFILE inputs will work on arbitrary images.
# - make the "output directory populated" ("_assembled") target depend on the
#   hard link being up to date
# - implement the hard link rule (that depends on the built tarball)
$(foreach i,$(LOCAL_PKGS),
$(if $(wildcard $(HCP_BUILD_SRC_$i)/hcp.Dockerfile),
$(LOCAL_DFILE): $(HCP_BUILD_SRC_$i)/hcp.Dockerfile
$(eval LOCAL_DFILE_INPUTS += $(HCP_BUILD_SRC_$i)/hcp.Dockerfile)
)
$(LOCAL_CTX_TFILE): $(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz
$(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz: | $(LOCAL_CTX)
$(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz: $(HCP_BUILD_RESULT_TGZ_$i)
	$Qecho "Linking in $(LOCAL_ANAME) <-- $i"
	$Qrm -f $$@ && ln $$< $$@
)

# The rule to generate the Dockerfile
# - command to derive from the appropriate parent image (LOCAL_ANCESTOR)
# - concatenate commands from the "hcp.Dockerfile"s of all packages that have
#   them
# - commands to inject the packages into the image
$(eval LOCAL_DFILE_XTRA := echo "\#\#\# Adding any caller-supplied extras")
$(if $(LOCAL_DFILE_ENTRYPOINT),\
$(eval LOCAL_DFILE_XTRA += && echo "ENTRYPOINT $(LOCAL_DFILE_ENTRYPOINT)"))
$(if $(LOCAL_DFILE_CMD),\
$(eval LOCAL_DFILE_XTRA += && echo "CMD $(LOCAL_DFILE_CMD)"))
$(if $(LOCAL_PKGS),\
$(eval LOCAL_DFILE_COPYCMD := COPY $(foreach i,$(LOCAL_PKGS),$i.tar.gz) /)\
$(eval LOCAL_DFILE_RUNCMD := RUN $(foreach i,$(LOCAL_PKGS),tar zxf /$i.tar.gz -C / &&) rm /*.tar.gz),\
$(eval LOCAL_DFILE_COPYCMD := \# No COPY for this image)\
$(eval LOCAL_DFILE_RUNCMD := \# No RUN for this image))
$(LOCAL_DFILE):
	$Qecho "Generating $(LOCAL_ANAME) Dockerfile"
	$Qecho "###### Dockerfile generated by app_image()\n" > $(LOCAL_DFILE)
	$Qecho "FROM $(LOCAL_ANCESTOR)" >> $(LOCAL_DFILE)
	$Qfor i in $(LOCAL_DFILE_INPUTS); do \
		echo "\n### Importing from $$$$i\n" >> $(LOCAL_DFILE); \
		cat $$$$i >> $(LOCAL_DFILE); \
	done
	$Qecho "\n### Injecting packages\n" >> $(LOCAL_DFILE)
	$Qecho "$(LOCAL_DFILE_COPYCMD)" >> $(LOCAL_DFILE)
	$Qecho "$(LOCAL_DFILE_RUNCMD)" >> $(LOCAL_DFILE)
	$Q($(LOCAL_DFILE_XTRA)) >> $(LOCAL_DFILE)

$(if $(LOCAL_EXTBASE_TFILE),
$(LOCAL_EXTBASE_TFILE):
	$Qecho "Pulling external baseimage: $(LOCAL_EXTBASENAME)"
	$Qdocker pull $(LOCAL_EXTBASENAME)
	$Qtouch $$@
)

# Cleanup
# - only if our output directory exists, otherwise there shouldn't be anything
#   to clean up
# - add a sub-target for removing the docker image only if it has in fact been
#   built.
# - if we are derived from another image, ensure the cleanups happen in the
#   right order
$(if $(wildcard $(LOCAL_CTX)),
$(if $(wildcard $(LOCAL_TFILE)),
clean_apps_$(LOCAL_NAME)_image:
	$Qecho "Removing $(LOCAL_DNAME) container image"
	$Qdocker image rm $(LOCAL_DNAME)
clean_apps_$(LOCAL_NAME): clean_apps_$(LOCAL_NAME)_image
)
clean_apps_$(LOCAL_NAME):
	$Qecho "Cleaning $(LOCAL_DNAME) context area"
	$Qrm -f $(LOCAL_CTX_TFILE) $(LOCAL_DFILE) $(LOCAL_TFILE) $(LOCAL_EXTBASE_TFILE) \
		$(LOCAL_CTX)/*.tar.gz
	$Qrmdir $(LOCAL_CTX)
)
# Also, because app_image_post() creates cleanup dependencies to control ordering,
# this dep helps to ensure we don't get into a situation that breaks the cleanup.
$(if $(LOCAL_ANCESTOR),\
$(LOCAL_CTX): | $(HCP_$(LOCAL_ANCESTOR)_CTX)
)

# Registration in docker-compose.env
$(eval APP_IMAGES += $(LOCAL_NAME))

endef

# Once all the apps have been registered via app_image(), this post-processing
# step adds the cleanup ordering dependencies. Note, the requirement here is
# that the behavior be recursive, but this is problematic in make (there are no
# local variables). So we implement a breadth-first algorithm. The
# app_image_post() wrapper sets a global APP_IMAGES_TODO variable equal to the
# base-level app(s), and then __app_image_post() runs repeatedly until that
# variable is empty. Each time __app_image_post() runs, it copies the variable
# and then zeroes it out, so that the next iteration only processes things that
# were identified in the previous iteration. That's why it's breadth-first.
# Ironically though, we use recursion anyway because GNU make doesn't have a
# loop construct! (Except for 'foreach', which doesn't apply here.) So the end
# of __app_image_post() calls __app_image_post() iff APP_IMAGES_TODO is
# non-empty, so we fake list iteration with a recursive call chain. In this
# form though, the issue with local variables isn't a problem, because we don't
# care if they've been clobbered when the calls return.
define __app_image_post
$(eval LOCAL_TODO := $(APP_IMAGES_TODO))
$(eval APP_IMAGES_TODO :=)
$(foreach x,$(LOCAL_TODO),
$(eval LOCAL_DEPENDEES := $(strip $(HCP_$x_DEPENDEES)))
$(foreach y,$(LOCAL_DEPENDEES),
$(if $(wildcard $(HCP_$y_TFILE)),
clean_apps_$x_image: clean_apps_$y_image
)
$(if $(wildcard $(HCP_$y_CTX)),
clean_apps_$x: clean_apps_$y
$(eval APP_IMAGES_TODO += $y)
)))
$(if $(APP_IMAGES_TODO),
$(eval $(call __app_image_post)))
endef
define app_image_post
$(eval APP_IMAGES_TODO := $(strip $1))
$(foreach x,$(APP_IMAGES_TODO),\
$(if $(wildcard $(HCP_$x_CTX)),
clean_apps: clean_apps_$x
))
$(eval $(call __app_image_post))
endef

# The docker-compose support expects to start certain apps (services and tools)
# and expects to be told what images to use for them. When an image is built
# specifically for that app, it has the same name and so the app_image() code
# above registers that image in APP_IMAGES. If instead another (superset) image
# should be used for that application purpose, this app_alias() code registers
# that in APP_ALIASES.
# $1 - name of the image to create an alias for
# $2 - name of the image to use for that alias
define app_alias
$(eval LOCAL_NAME := $(strip $1))
$(eval LOCAL_TGT := $(strip $2))
$(eval APP_ALIASES += $(LOCAL_NAME))
$(eval APP_ALIAS_$(LOCAL_NAME) := $(LOCAL_TGT))
endef
