# $1 - name of the image (can be referred to later as $(call HCP_IMAGE,<name>))
# $2 - name of ancestor image (or empty if it should derive from base-platform)
# $3 - source packages to inject
define app_image

$(eval LOCAL_NAME := $(strip $1))
$(eval LOCAL_CTX := $(HCP_APPS_OUT)/$(LOCAL_NAME))
$(eval LOCAL_CTX_TFILE := $(LOCAL_CTX)/_assembled)
$(eval LOCAL_ANAME := app_$(LOCAL_NAME))
$(eval LOCAL_DNAME := $(call HCP_IMAGE,$(LOCAL_NAME)))
$(eval HCP_$(LOCAL_NAME)_DNAME := $(LOCAL_DNAME))
$(eval LOCAL_TFILE := $(LOCAL_CTX)/_built)
$(eval HCP_$(LOCAL_NAME)_TFILE := $(LOCAL_TFILE))
$(eval LOCAL_DFILE := $(LOCAL_CTX)/Dockerfile)
$(eval LOCAL_DFILE_INPUTS :=)
$(eval HCP_$(LOCAL_NAME)_DFILE := $(LOCAL_DFILE))
$(eval LOCAL_ANCESTOR := $(strip $2))
$(if $(LOCAL_ANCESTOR),\
$(eval HCP_$(LOCAL_NAME)_DEP := $(LOCAL_ANCESTOR))\
$(eval HCP_$(LOCAL_ANCESTOR)_DEPENDEE := 1)\
$(eval LOCAL_ANCESTOR_TFILE := $(HCP_$(LOCAL_ANCESTOR)_TFILE))\
$(eval LOCAL_ANCESTOR := $(call HCP_IMAGE,$(LOCAL_ANCESTOR)))\
,\
$(eval LOCAL_ANCESTOR_TFILE := $(HCP_BASE_TOUCHFILE))\
$(eval LOCAL_ANCESTOR := $(HCP_BASE_DNAME))\
)
$(eval LOCAL_PKGS := $(strip $3))
$(eval HCP_$(LOCAL_NAME)_CTX := $(LOCAL_CTX))

$(eval APPS_NAMES += $(LOCAL_NAME))

# Output directory created ("./output/apps/<foo>")
$(LOCAL_CTX): | $(HCP_APPS_OUT)
MDIRS += $(LOCAL_CTX)

# Symbolic target ("make app_<foo>")
$(LOCAL_ANAME): $(LOCAL_TFILE)

# Touchfile when fully built ("./output/apps/<foo>/_built"), depends;
# - output directory contents up to date (CTX_FILE)
# - parent container image up to date (ANCESTOR_TFILE)
$(LOCAL_TFILE): $(LOCAL_CTX_TFILE)
$(LOCAL_TFILE): $(LOCAL_ANCESTOR_TFILE)
$(LOCAL_TFILE):
	$Qecho "Building $(LOCAL_DNAME) container image"
	$Qdocker build \
		-t $(LOCAL_DNAME) \
		-f $(LOCAL_DFILE) \
		$(LOCAL_CTX)
	$Qtouch $$@

# Output directory populated ("./output/apps/<foo>/_assembled"), depends;
# - Dockerfile up to date (DFILE)
# - all package (tarball) hard links are up to date (these deps are added in
#   the per-package loop further down)
$(LOCAL_CTX_TFILE): $(LOCAL_DFILE)
$(LOCAL_CTX_TFILE):
	$Qtouch $$@

# Dockerfile generated ("./output/apps/<foo>/Dockerfile"), depends;
# - output directory created ("|" CTX)
# - all per-package "hcp.Dockerfile" files (these deps are added in the
#   per-package loop further down)
# The rule for this target is implemented after the per-package loop
$(LOCAL_DFILE): | $(LOCAL_CTX)

# Per-package loop
# - if the package has a "hcp.Dockerfile", it will form part of the
#   LOCAL_DFILE, so declare a dependency accordingly (also remember this
#   in LOCAL_DFILE_INPUTS to implement Dockerfile-generation)
# - make the "output directory populated" ("_assembled") target depend on the
#   hard link being up to date
# - implement the hard link rule (that depends on the built tarball)
$(foreach i,$(LOCAL_PKGS),
$(if $(wildcard $(HCP_BUILD_SRC_$i)/hcp.Dockerfile),
$(LOCAL_DFILE): $(HCP_BUILD_SRC_$i)/hcp.Dockerfile
$(eval LOCAL_DFILE_INPUTS += $(HCP_BUILD_SRC_$i)/hcp.Dockerfile)
)
$(LOCAL_CTX_TFILE): $(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz
$(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz: | $(LOCAL_CTX)
$(LOCAL_CTX)/$(HCP_BUILD_TGZ_$i).tar.gz: $(HCP_BUILD_RESULT_TGZ_$i)
	$Qecho "Linking in $(LOCAL_ANAME) <-- $i"
	$Qrm -f $$@ && ln $$< $$@
)

# The to generate the Dockerfile
# - command to derive from the appropriate parent image (LOCAL_ANCESTOR)
# - concatenate commands from the "hcp.Dockerfile"s of all packages that have
#   them
# - commands to inject the packages into the image
$(LOCAL_DFILE):
	$Qecho "Generating $(LOCAL_ANAME) Dockerfile"
	$Qecho "###### Dockerfile generated by app_image()\n" > $(LOCAL_DFILE)
	$Qecho "FROM $(LOCAL_ANCESTOR)" >> $(LOCAL_DFILE)
	$Qfor i in $(LOCAL_DFILE_INPUTS); do \
		echo "\n### Importing from $$$$i\n" >> $(LOCAL_DFILE); \
		cat $$$$i >> $(LOCAL_DFILE); \
	done
	$Qecho "\n### Injecting packages\n" >> $(LOCAL_DFILE)
	$Qecho "COPY *.tar.gz /" >> $(LOCAL_DFILE)
	$Qecho "RUN $(foreach i,$(LOCAL_PKGS),tar zxf /$i.tar.gz -C / &&) rm /*.tar.gz" \
		>> $(LOCAL_DFILE)

# Cleanup
# - only if our output directory exists, otherwise there shouldn't be anything
#   to clean up
# - if we are derived from another image, ensure the cleanups happen in the
#   right order
$(if $(wildcard $(LOCAL_CTX)),
$(if $(wildcard $(LOCAL_TFILE)),
clean_apps_$(LOCAL_NAME)_image:
	$Qecho "Removing $(LOCAL_DNAME) container image"
	$Qdocker image rm $(LOCAL_DNAME)
clean_apps_$(LOCAL_NAME): clean_apps_$(LOCAL_NAME)_image
$(if $(HCP_$(LOCAL_NAME)_DEP),
clean_apps_$(LOCAL_NAME)_image: clean_apps_$(HCP_$(LOCAL_NAME)_DEP)_image
)
)
clean_apps_$(LOCAL_NAME):
	$Qecho "Cleaning $(LOCAL_DNAME) context area"
	$Qrm -f $(LOCAL_CTX_TFILE) $(LOCAL_DFILE) $(LOCAL_TFILE) \
		$(LOCAL_CTX)/*.tar.gz
	$Qrmdir $(LOCAL_CTX)
$(if $(HCP_$(LOCAL_NAME)_DEPENDEE),,
clean_apps: clean_apps_$(LOCAL_NAME)
)
)

# Registration in docker-compose.env
$(eval APP_IMAGES += $(LOCAL_NAME))

endef

# The docker-compose support expects to start certain apps (services and tools)
# and expects to be told what images to use for them. When an image is built
# specifically for that app, it has the same name and so the app_image() code
# above registers that image in APP_IMAGES. If instead another (superset) image
# should be used for that application purpose, this app_alias() code registers
# that in APP_ALIASES.
# $1 - name of the image to create an alias for
# $2 - name of the image to use for that alias
define app_alias
$(eval LOCAL_NAME := $(strip $1))
$(eval LOCAL_TGT := $(strip $2))
$(eval APP_ALIASES += $(LOCAL_NAME))
$(eval APP_ALIAS_$(LOCAL_NAME) := $(LOCAL_TGT))
endef
