#!/bin/bash

. /hcp/common/hcp.sh

# As a general rule, we do attestation before all the initialization flow.
# However, our attestation callback relies on the existence of
# $HCP_KDC_STATE/etc because it deposits our credential there, so take care of
# that pre-attestation.
if [[ -z $HCP_KDC_STATE ]]; then
	echo "Error, 'HCP_KDC_STATE' not defined" >&2
	exit 1
fi
if [[ ! -d $HCP_KDC_STATE ]]; then
	echo "Error, '$HCP_KDC_STATE' (HCP_KDC_STATE) doesn't exist" >&2
	exit 1
fi
mkdir -p $HCP_KDC_STATE/etc

# Run the attestation and get our assets
# Note, run_client is not a service, it's a utility, so it doesn't retry
# forever waiting for things to be ready to succeed. We, on the other hand,
# _are_ a service, so we need to be more forgiving.
attestlog=$(mktemp)
if ! /hcp/tools/run_client.sh 2> $attestlog; then
	echo "Warning: the attestation client lost patience, error output follows;" >&2
	cat $attestlog >&2
	rm $attestlog
	echo "Warning: suppressing error output from future attestation attempts" >&2
	attestation_done=
	until [[ -n $attestation_done ]]; do
		echo "Warning: waiting 10 seconds before retring attestation" >&2
		sleep 10
		echo "Retrying attestation" >&2
		/hcp/tools/run_client.sh 2> /dev/null && attestation_done=yes
	done
fi

if [[ -x /install/libexec/kdc ]]; then
	KDC_BIN=/install/libexec/kdc
elif [[ -x /usr/lib/heimdal-servers/kdc ]]; then
	KDC_BIN=/usr/lib/heimdal-servers/kdc
else
	echo "Error, no KDC binary found"
	exit 1
fi
if [[ -x /install/libexec/kpasswdd ]]; then
	KPASSWDD_BIN=/install/libexec/kpasswdd
elif [[ -x /usr/lib/heimdal-servers/kpasswdd ]]; then
	KPASSWDD_BIN=/usr/lib/heimdal-servers/kpasswdd
else
	echo "Error, no KPASSWDD binary found"
	exit 1
fi

MYETC=$HCP_KDC_STATE/etc
MYVAR=$HCP_KDC_STATE/var

# Handle first-time init of persistent state, part 1.
if [[ ! -f $HCP_KDC_STATE/initialized ]]; then

	echo "Initializing KDC state"
	if [[ -z $HCP_KDC_REALM ]]; then
		echo "Error, HCP_KDC_REALM isn't set" >&2
		exit 1
	fi
	# mkdir $MYETC  # We do this pre-attestation
	mkdir $MYVAR

	# Generate the 'kdc' stuff to be added to the /etc/krb5.conf provided
	# by attestation.
	echo "Creating $MYETC/krb5.conf.kdc-extras"
	cat > $MYETC/krb5.conf.kdc-extras << EOF
# Autogenerated from run_kdc.sh
[kdc]
	pkinit_identity = FILE:$MYETC/kdc-cert.pem
	pkinit_anchors = FILE:/usr/share/ca-certificates/HCP/certissuer.pem
	#pkinit_pool = PKCS12:/path/to/useful-intermediate-certs.pfx
	#pkinit_pool = FILE:/path/to/other-useful-intermediate-certs.pem
	pkinit_allow_proxy_certificate = no
	pkinit_win2k_require_binding = yes
	pkinit_principal_in_certificate = yes
EOF

	# Produce script.kadmin
	echo "Creating $MYETC/script.kadmin"
	cat > $MYETC/script.kadmin << EOF
init --realm-max-ticket-life=unlimited --realm-max-renewable-life=unlimited $HCP_KDC_REALM
ext_keytab --keytab=$MYVAR/kadmin.keytab kadmin/admin kadmin/changepw
add --use-defaults -p adminpassword adminuser@$HCP_KDC_REALM
EOF
	# Produce kdc.conf
	echo "Creating $MYETC/kdc.conf"
	cat > $MYETC/kdc.conf << EOF
[logging]
kdc = STDERR
[kdc]
database = {
  dbname = $MYVAR/heimdal
  acl = $MYETC/kadmind.acl
  log_file = $MYVAR/kdc.log
}
EOF
fi

# On all start-ups, twiddle the rootfs
echo "Reworking system config"
if [[ ! -f /etc/krb5.conf ]]; then
	echo "Error, no /etc/krb5.conf found"
	exit 1
fi
if [[ -f /etc/krb5.conf.merged ]]; then
	echo "Already merged /etc/krb5.conf, skipping"
else
	echo "Merging $MYETC/krb5.conf.kdc-extras into /etc/krb5.conf"
	cat "$MYETC/krb5.conf.kdc-extras" >> /etc/krb5.conf
	touch /etc/krb5.conf.merged
fi

# Handle first-time init of persistent state, part 2.
if [[ ! -f $HCP_KDC_STATE/initialized ]]; then
	echo "Initializing KDC via 'kadmin -l'"
	kadmin --config-file=$MYETC/kdc.conf -l < $MYETC/script.kadmin
	touch $HCP_KDC_STATE/initialized
fi

# Start the service and handle signals
echo "Starting the KDC"
CHILDPID_KDC=0
CHILDPID_KPASSWDD=0
trap 'kill $CHILDPID_KDC ; kill $CHILDPID_KPASSWDD' TERM QUIT
$KDC_BIN --config-file=$MYETC/kdc.conf &
CHILDPID_KDC=$!
$KPASSWDD_BIN &
CHILDPID_KPASSWDD=$!
wait $CHILDPID_KDC $CHILDPID_KPASSWDD
